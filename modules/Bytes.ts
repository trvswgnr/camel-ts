// Generated by Melange

import * as Caml_bytes from "../melange.js/caml_bytes.mjs";
import * as Caml_js_exceptions from "../melange.js/caml_js_exceptions.mjs";
import * as Curry from "../melange.js/curry.mjs";
import * as Stdlib from "../melange/stdlib.mjs";
import * as Stdlib__Char from "../melange/char.mjs";
import * as Stdlib__Int from "../melange/int.mjs";
import * as Stdlib__Seq from "../melange/seq.mjs";
import * as Stdlib__Sys from "../melange/sys.mjs";
import * as Stdlib__Uchar from "../melange/uchar.mjs";
import type { int } from "./Int";
import type { Nominal } from "../utils";
import type { unit } from "./Unit";
import type { list } from "./List";
import List from "./List";
import Char from "./Char";
import type { option } from "./Option";
import Option from "./Option";
import type { bool } from "./Bool";
import { seq } from "./Seq";

function make(n: int, c: int) {
    var s = Caml_bytes.caml_create_bytes(n);
    Caml_bytes.caml_fill_bytes(s, 0, n, c);
    return s;
}

function init(n: int, f: (i: int) => int) {
    var s = Caml_bytes.caml_create_bytes(n);
    for (var i = 0; i < n; ++i) {
        s[i] = Curry._1(f, i);
    }
    return s;
}

type bytes = Nominal<Array<int>, "Bytes">;

const empty: bytes = [] as any;

function copy(s: bytes): bytes {
    var len = s.length;
    var r = Caml_bytes.caml_create_bytes(len);
    Caml_bytes.caml_blit_bytes(s, 0, r, 0, len);
    return r as bytes;
}

function to_string(b: bytes): string {
    return Caml_bytes.bytes_to_string(copy(b));
}

function of_string(s: string): bytes {
    return copy(Caml_bytes.bytes_of_string(s) as bytes);
}

function sub(s: bytes, ofs: int, len: int): bytes {
    if (ofs < 0 || len < 0 || ofs > ((s.length - len) | 0)) {
        return Stdlib.invalid_arg("String.sub / Bytes.sub") as any;
    }
    var r = Caml_bytes.caml_create_bytes(len);
    Caml_bytes.caml_blit_bytes(s, ofs, r, 0, len);
    return r as bytes;
}

function sub_string(b: bytes, ofs: int, len: int): string {
    return Caml_bytes.bytes_to_string(sub(b, ofs, len));
}

function $plus$plus(a: int, b: int): int {
    var c = (a + b) | 0;
    var match = a < 0;
    var match$1 = b < 0;
    var match$2 = c < 0;
    if (match) {
        if (match$1 && !match$2) {
            return Stdlib.invalid_arg("Bytes.extend") as any;
        } else {
            return c as int;
        }
    } else if (match$1 || !match$2) {
        return c as int;
    } else {
        return Stdlib.invalid_arg("Bytes.extend") as any;
    }
}

function extend(s: bytes, left: int, right: int): bytes {
    var len = $plus$plus($plus$plus(s.length as int, left), right);
    var r = Caml_bytes.caml_create_bytes(len);
    var match = left < 0 ? [-left | 0, 0] : [0, left];
    var dstoff = match[1];
    var srcoff = match[0];
    var cpylen = Stdlib__Int.min(
        (s.length - (srcoff as int)) | 0,
        (len - (dstoff as int)) | 0,
    );
    if (cpylen > 0) {
        Caml_bytes.caml_blit_bytes(s, srcoff, r, dstoff, cpylen);
    }
    return r as bytes;
}

function fill(s: bytes, ofs: int, len: int, c: int): unit {
    if (ofs < 0 || len < 0 || ofs > ((s.length - len) | 0)) {
        return Stdlib.invalid_arg("String.fill / Bytes.fill") as any;
    } else {
        return Caml_bytes.caml_fill_bytes(s, ofs, len, c) as unit;
    }
}

function blit(s1: bytes, ofs1: int, s2: bytes, ofs2: int, len: int): unit {
    if (
        len < 0 ||
        ofs1 < 0 ||
        ofs1 > ((s1.length - len) | 0) ||
        ofs2 < 0 ||
        ofs2 > ((s2.length - len) | 0)
    ) {
        return Stdlib.invalid_arg("Bytes.blit") as any;
    } else {
        return Caml_bytes.caml_blit_bytes(s1, ofs1, s2, ofs2, len) as unit;
    }
}

function blit_string(
    s1: bytes,
    ofs1: int,
    s2: bytes,
    ofs2: int,
    len: int,
): unit {
    if (
        len < 0 ||
        ofs1 < 0 ||
        ofs1 > ((s1.length - len) | 0) ||
        ofs2 < 0 ||
        ofs2 > ((s2.length - len) | 0)
    ) {
        return Stdlib.invalid_arg("String.blit / Bytes.blit_string");
    } else {
        return Caml_bytes.caml_blit_string(s1, ofs1, s2, ofs2, len) as unit;
    }
}

function iter(f: (a: int) => unit, a: bytes): unit {
    for (var i = 0, i_finish = a.length; i < i_finish; ++i) {
        Curry._1(f, a[i]);
    }
}

function iteri(f: (i: int, a: int) => unit, a: bytes): unit {
    for (var i = 0, i_finish = a.length; i < i_finish; ++i) {
        Curry._2(f, i, a[i]);
    }
}

function ensure_ge(x: int, y: int): int {
    if (x >= y) {
        return x;
    } else {
        return Stdlib.invalid_arg("Bytes.concat");
    }
}

function sum_lengths(_acc: int, seplen: int, _param: any) {
    while (true) {
        var param = _param;
        var acc = _acc;
        if (!param) {
            return acc;
        }
        var hd = param.hd;
        if (!param.tl) {
            return (hd.length + acc) | 0;
        }
        _param = param.tl;
        _acc = ensure_ge(
            ((((hd.length + seplen) as int | 0) + acc) | 0) as int,
            acc,
        );
        continue;
    }
}

function unsafe_blits(
    dst: bytes,
    _pos: int,
    sep: bytes,
    seplen: int,
    _param: list<bytes>,
) {
    while (true) {
        var param = _param;
        var pos = _pos;
        if (!param || !List.is_cons(param)) {
            return dst;
        }
        var hd = param.hd;
        if (param.tl) {
            Caml_bytes.caml_blit_bytes(hd, 0, dst, pos, hd.length);
            Caml_bytes.caml_blit_bytes(
                sep,
                0,
                dst,
                (pos + hd.length) | 0,
                seplen,
            );
            _param = param.tl;
            _pos = ((((pos + hd.length) | 0) + seplen) | 0) as int;
            continue;
        }
        Caml_bytes.caml_blit_bytes(hd, 0, dst, pos, hd.length);
        return dst;
    }
}

function concat(sep: bytes, l: list<bytes>): bytes {
    if (!l) {
        return empty;
    }
    var seplen = sep.length;
    return unsafe_blits(
        Caml_bytes.caml_create_bytes(sum_lengths(0 as int, seplen as int, l)) as bytes,
        0 as int,
        sep,
        seplen as int,
        l,
    );
}

function cat(s1: bytes, s2: bytes): bytes {
    var l1 = s1.length;
    var l2 = s2.length;
    var r = Caml_bytes.caml_create_bytes((l1 + l2) | 0);
    Caml_bytes.caml_blit_bytes(s1, 0, r, 0, l1);
    Caml_bytes.caml_blit_bytes(s2, 0, r, l1, l2);
    return r as bytes;
}

function is_space(param: int): bool {
    if (param > 13 || param < 9) {
        return param === 32;
    } else {
        return param !== 11;
    }
}

function trim(s: bytes): bytes {
    var len = s.length;
    var i = 0;
    while (i < len && is_space(s[i]!)) {
        i = (i + 1) | 0;
    }
    var j = (len - 1) | 0;
    while (j >= i && is_space(s[j]!)) {
        j = (j - 1) | 0;
    }
    if (j >= i) {
        return sub(s, i as int, ((((j - i) | 0) + 1) | 0) as int);
    } else {
        return empty;
    }
}

function unsafe_escape(s: bytes): bytes {
    var n = 0;
    for (var i = 0, i_finish = s.length; i < i_finish; ++i) {
        var match = s[i];
        if (match === undefined) {
            continue;
        }
        n =
            (n +
                (match >= 32
                    ? match > 92 || match < 34
                        ? match >= 127
                            ? 4
                            : 1
                        : match > 91 || match < 35
                        ? 2
                        : 1
                    : match >= 11
                    ? match !== 13
                        ? 4
                        : 2
                    : match >= 8
                    ? 2
                    : 4)) |
            0;
    }
    if (n === s.length) {
        return s;
    }
    var s$p = Caml_bytes.caml_create_bytes(n);
    n = 0;
    for (var i$1 = 0, i_finish$1 = s.length; i$1 < i_finish$1; ++i$1) {
        var c = s[i$1];
        if (c === undefined) {
            continue;
        }
        var exit = 0;
        if (c >= 35) {
            if (c !== 92) {
                if (c >= 127) {
                    exit = 1;
                } else {
                    s$p[n] = c;
                }
            } else {
                exit = 2;
            }
        } else if (c >= 32) {
            if (c >= 34) {
                exit = 2;
            } else {
                s$p[n] = c;
            }
        } else if (c >= 14) {
            exit = 1;
        } else {
            switch (c) {
                case 8:
                    s$p[n] = /* '\\' */ 92;
                    n = (n + 1) | 0;
                    s$p[n] = /* 'b' */ 98;
                    break;
                case 9:
                    s$p[n] = /* '\\' */ 92;
                    n = (n + 1) | 0;
                    s$p[n] = /* 't' */ 116;
                    break;
                case 10:
                    s$p[n] = /* '\\' */ 92;
                    n = (n + 1) | 0;
                    s$p[n] = /* 'n' */ 110;
                    break;
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 11:
                case 12:
                    exit = 1;
                    break;
                case 13:
                    s$p[n] = /* '\\' */ 92;
                    n = (n + 1) | 0;
                    s$p[n] = /* 'r' */ 114;
                    break;
            }
        }
        switch (exit) {
            case 1:
                s$p[n] = /* '\\' */ 92;
                n = (n + 1) | 0;
                s$p[n] = (48 + ((c / 100) | 0)) | 0;
                n = (n + 1) | 0;
                s$p[n] = (48 + (((c / 10) | 0) % 10)) | 0;
                n = (n + 1) | 0;
                s$p[n] = (48 + (c % 10)) | 0;
                break;
            case 2:
                s$p[n] = /* '\\' */ 92;
                n = (n + 1) | 0;
                s$p[n] = c;
                break;
        }
        n = (n + 1) | 0;
    }
    return s$p as bytes;
}

function escaped(b: bytes): bytes {
    return unsafe_escape(copy(b));
}

function map(f: (a: int) => int, s: bytes): bytes {
    var l = s.length;
    if (l === 0) {
        return s;
    }
    var r = Caml_bytes.caml_create_bytes(l);
    for (var i = 0; i < l; ++i) {
        r[i] = Curry._1(f, s[i]);
    }
    return r as bytes;
}

function mapi(f: (i: int, a: int) => int, s: bytes): bytes {
    var l = s.length;
    if (l === 0) {
        return s;
    }
    var r = Caml_bytes.caml_create_bytes(l);
    for (var i = 0; i < l; ++i) {
        r[i] = Curry._2(f, i, s[i]);
    }
    return r as bytes;
}

function fold_left(f: (x: int, a: int) => int, x: int, a: bytes): int {
    var r = x;
    for (var i = 0, i_finish = a.length; i < i_finish; ++i) {
        r = Curry._2(f, r, a[i]);
    }
    return r;
}

function fold_right(f: (a: int, x: int) => int, a: bytes, x: int): int {
    var r = x;
    for (var i = (a.length - 1) | 0; i >= 0; --i) {
        r = Curry._2(f, a[i], r);
    }
    return r;
}

function exists(p: (a: int) => bool, s: bytes): bool {
    var n = s.length;
    var _i = 0;
    while (true) {
        var i = _i;
        if (i === n) {
            return false;
        }
        if (Curry._1(p, s[i])) {
            return true;
        }
        _i = (i + 1) | 0;
        continue;
    }
}

function for_all(p: (a: int) => bool, s: bytes): bool {
    var n = s.length;
    var _i = 0;
    while (true) {
        var i = _i;
        if (i === n) {
            return true;
        }
        if (!Curry._1(p, s[i])) {
            return false;
        }
        _i = (i + 1) | 0;
        continue;
    }
}

function uppercase_ascii(s: bytes): bytes {
    return map(Stdlib__Char.uppercase_ascii, s);
}

function lowercase_ascii(s: bytes): bytes {
    return map(Stdlib__Char.lowercase_ascii, s);
}

function apply1(f: (a: int) => int, s: bytes): bytes {
    if (s.length === 0) {
        return s;
    }
    var r = copy(s);
    r[0] = Curry._1(f, s[0]);
    return r;
}

function capitalize_ascii(s: bytes): bytes {
    return apply1(Stdlib__Char.uppercase_ascii, s);
}

function uncapitalize_ascii(s: bytes): bytes {
    return apply1(Stdlib__Char.lowercase_ascii, s);
}

function starts_with(prefix: bytes, s: bytes): bool {
    var len_s = s.length;
    var len_pre = prefix.length;
    if (len_s >= len_pre) {
        var _i = 0;
        while (true) {
            var i = _i;
            if (i === len_pre) {
                return true;
            }
            if (s[i] !== prefix[i]) {
                return false;
            }
            _i = (i + 1) | 0;
            continue;
        }
    } else {
        return false;
    }
}

function ends_with(suffix: bytes, s: bytes): bool {
    var len_s = s.length;
    var len_suf = suffix.length;
    var diff = (len_s - len_suf) | 0;
    if (diff >= 0) {
        var _i = 0;
        while (true) {
            var i = _i;
            if (i === len_suf) {
                return true;
            }
            if (s[(diff + i) | 0] !== suffix[i]) {
                return false;
            }
            _i = (i + 1) | 0;
            continue;
        }
    } else {
        return false;
    }
}

function index_rec(s: bytes, lim: int, _i: int, c: int): int {
    while (true) {
        var i = _i;
        if (i >= lim) {
            throw {
                RE_EXN_ID: Stdlib.Not_found,
                Error: new Error(),
            };
        }
        if (s[i] === c) {
            return i;
        }
        _i = ((i + 1) | 0) as int;
        continue;
    }
}

function index(s: bytes, c: int): int {
    return index_rec(s, s.length as int, 0 as int, c);
}

function index_rec_opt(
    s: bytes,
    lim: number,
    _i: number,
    c: number,
): option<int> {
    while (true) {
        var i = _i;
        if (i >= lim) {
            return Option.none();
        }
        if (s[i] === c) {
            return Option.some(i as int);
        }
        _i = (i + 1) | 0;
        continue;
    }
}

function index_opt(s: bytes, c: int): option<int> {
    return index_rec_opt(s, s.length, 0, c);
}

function index_from(s: bytes, i: int, c: int): int {
    var l = s.length;
    if (i < 0 || i > l) {
        return Stdlib.invalid_arg("String.index_from / Bytes.index_from");
    } else {
        return index_rec(s, l as int, i as int, c);
    }
}

function index_from_opt(s: bytes, i: int, c: int): option<int> {
    var l = s.length;
    if (i < 0 || i > l) {
        return Stdlib.invalid_arg(
            "String.index_from_opt / Bytes.index_from_opt",
        );
    } else {
        return index_rec_opt(s, l, i, c);
    }
}

function rindex_rec(s: bytes, _i: int, c: int): int {
    while (true) {
        var i = _i;
        if (i < 0) {
            throw {
                RE_EXN_ID: Stdlib.Not_found,
                Error: new Error(),
            };
        }
        if (s[i] === c) {
            return i;
        }
        _i = ((i - 1) | 0) as int;
        continue;
    }
}

function rindex(s: bytes, c: int): int {
    return rindex_rec(s, ((s.length - 1) | 0) as int, c);
}

function rindex_from(s: bytes, i: int, c: int): int {
    if (i < -1 || i >= s.length) {
        return Stdlib.invalid_arg("String.rindex_from / Bytes.rindex_from");
    } else {
        return rindex_rec(s, i, c);
    }
}

function rindex_rec_opt(s: bytes, _i: int, c: int): option<int> {
    while (true) {
        var i = _i;
        if (i < 0) {
            return Option.none();
        }
        if (s[i] === c) {
            return Option.some(i as int);
        }
        _i = ((i - 1) | 0) as int;
        continue;
    }
}

function rindex_opt(s: bytes, c: int): option<int> {
    return rindex_rec_opt(s, ((s.length - 1) | 0) as int, c);
}

function rindex_from_opt(s: bytes, i: int, c: int): option<int> {
    if (i < -1 || i >= s.length) {
        return Stdlib.invalid_arg(
            "String.rindex_from_opt / Bytes.rindex_from_opt",
        );
    } else {
        return rindex_rec_opt(s, i, c);
    }
}

function contains_from(s: bytes, i: int, c: int): bool {
    var l = s.length;
    if (i < 0 || i > l) {
        return Stdlib.invalid_arg("String.contains_from / Bytes.contains_from");
    }
    try {
        index_rec(s, l as int, i as int, c);
        return true;
    } catch (raw_exn) {
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === Stdlib.Not_found) {
            return false;
        }
        throw exn;
    }
}

function contains(s: bytes, c: int): bool {
    return contains_from(s, 0 as int, c);
}

function rcontains_from(s: bytes, i: int, c: int): bool {
    if (i < 0 || i >= s.length) {
        return Stdlib.invalid_arg(
            "String.rcontains_from / Bytes.rcontains_from",
        );
    }
    try {
        rindex_rec(s, i, c);
        return true;
    } catch (raw_exn) {
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === Stdlib.Not_found) {
            return false;
        }
        throw exn;
    }
}

const compare = Caml_bytes.caml_bytes_compare;

function split_on_char(sep: int, s: bytes): list<bytes> {
    let r: list<bytes> = List.empty();
    var j = s.length;
    for (var i = (s.length - 1) | 0; i >= 0; --i) {
        if (s[i] === sep) {
            r = {
                hd: sub(
                    s,
                    ((i + 1) | 0) as int,
                    ((((j - i) | 0) - 1) | 0) as int,
                ),
                tl: r,
            } as list<bytes>;
            j = i;
        }
    }
    return {
        hd: sub(s, 0 as int, j as int),
        tl: r,
    } as list<bytes>;
}

function to_seq(s: bytes): seq<int> {
    var aux = function (i: int, param: any) {
        if (i === s.length) {
            return /* Nil */ 0;
        }
        var x = Caml_bytes.get(s, i);
        var partial_arg = (i + 1) | 0;
        return /* Cons */ {
            _0: x,
            _1: function (param: any) {
                return aux(partial_arg as int, param);
            },
        };
    };
    return seq((param: any) => aux(0 as int, param));
}

function to_seqi(s: bytes): seq<int> {
    var aux = function (i: int, param: any) {
        if (i === s.length) {
            return /* Nil */ 0;
        }
        var x = Caml_bytes.get(s, i);
        var partial_arg = (i + 1) | 0;
        return /* Cons */ {
            _0: [i, x],
            _1: function (param: any) {
                return aux(partial_arg as int, param);
            },
        };
    };
    return seq((param: any) => aux(0 as int, param));
}

function of_seq(i: seq<int>): bytes {
    var n = {
        contents: 0,
    };
    var buf = {
        contents: make(256 as int, /* '\000' */ 0 as int),
    };
    var resize = function (param: any) {
        var new_len = Stdlib__Int.min(
            buf.contents.length << 1,
            Stdlib__Sys.max_string_length,
        );
        if (buf.contents.length === new_len) {
            Stdlib.failwith("Bytes.of_seq: cannot grow bytes");
        }
        var new_buf = make(new_len, /* '\000' */ 0 as int);
        blit(buf.contents as bytes, 0 as int, new_buf as bytes, 0 as int, n.contents as int);
        buf.contents = new_buf;
    };
    Stdlib__Seq.iter(function (c: int) {
        if (n.contents === buf.contents.length) {
            resize(undefined);
        }
        Caml_bytes.set(buf.contents, n.contents, c);
        n.contents = (n.contents + 1) | 0;
    }, i);
    return sub(buf.contents as bytes, 0 as int, n.contents as int);
}

function unsafe_get_uint16_le(b: bytes, i: int): int {
    if (Stdlib__Sys.big_endian) {
        return Caml_bytes.bswap16(Caml_bytes.get16u(b, i)) as int;
    } else {
        return Caml_bytes.get16u(b, i) as int;
    }
}

function unsafe_get_uint16_be(b: bytes, i: int): int {
    if (Stdlib__Sys.big_endian) {
        return Caml_bytes.get16u(b, i) as int;
    } else {
        return Caml_bytes.bswap16(Caml_bytes.get16u(b, i)) as int;
    }
}

function get_int8(b: bytes, i: int): int {
    return (
        (Caml_bytes.get(b, i) << ((Stdlib__Sys.int_size - 8) | 0)) >>
        ((Stdlib__Sys.int_size - 8) | 0)
    ) as int;
}

function get_uint16_le(b: bytes, i: int): int {
    if (Stdlib__Sys.big_endian) {
        return Caml_bytes.bswap16(Caml_bytes.get16(b, i)) as int;
    } else {
        return Caml_bytes.get16(b, i) as int;
    }
}

function get_uint16_be(b: bytes, i: int): int {
    if (Stdlib__Sys.big_endian) {
        return Caml_bytes.get16(b, i) as int;
    } else {
        return Caml_bytes.bswap16(Caml_bytes.get16(b, i)) as int;
    }
}

function get_int16_ne(b: bytes, i: int): int {
    return (
        (Caml_bytes.get16(b, i) << ((Stdlib__Sys.int_size - 16) | 0)) >>
        ((Stdlib__Sys.int_size - 16) | 0)
    ) as int;
}

function get_int16_le(b: bytes, i: int): int {
    return (
        (get_uint16_le(b, i) << ((Stdlib__Sys.int_size - 16) | 0)) >>
        ((Stdlib__Sys.int_size - 16) | 0)
    ) as int;
}

function get_int16_be(b: bytes, i: int): int {
    return (
        (get_uint16_be(b, i) << ((Stdlib__Sys.int_size - 16) | 0)) >>
        ((Stdlib__Sys.int_size - 16) | 0)
    ) as int;
}

function get_int32_le(b: bytes, i: int): int {
    if (Stdlib__Sys.big_endian) {
        return Caml_bytes.bswap32(Caml_bytes.get32(b, i)) as int;
    } else {
        return Caml_bytes.get32(b, i) as int;
    }
}

function get_int32_be(b: bytes, i: int): int {
    if (Stdlib__Sys.big_endian) {
        return Caml_bytes.get32(b, i) as int;
    } else {
        return Caml_bytes.bswap32(Caml_bytes.get32(b, i)) as int;
    }
}

function get_int64_le(b: bytes, i: int): any {
    if (Stdlib__Sys.big_endian) {
        return Caml_bytes.bswap64(Caml_bytes.get64(b, i));
    } else {
        return Caml_bytes.get64(b, i);
    }
}

function get_int64_be(b: bytes, i: int): any {
    if (Stdlib__Sys.big_endian) {
        return Caml_bytes.get64(b, i);
    } else {
        return Caml_bytes.bswap64(Caml_bytes.get64(b, i));
    }
}

function unsafe_set_uint16_le(b: bytes, i: int, x: int): unit {
    if (Stdlib__Sys.big_endian) {
        return Caml_bytes.set16u(b, i, Caml_bytes.bswap16(x)) as unit;
    } else {
        return Caml_bytes.set16u(b, i, x) as unit;
    }
}

function unsafe_set_uint16_be(b: bytes, i: int, x: int): unit {
    if (Stdlib__Sys.big_endian) {
        return Caml_bytes.set16u(b, i, x) as unit;
    } else {
        return Caml_bytes.set16u(b, i, Caml_bytes.bswap16(x)) as unit;
    }
}

function set_int16_le(b: bytes, i: int, x: int): unit {
    if (Stdlib__Sys.big_endian) {
        return Caml_bytes.set16(b, i, Caml_bytes.bswap16(x)) as unit;
    } else {
        return Caml_bytes.set16(b, i, x) as unit;
    }
}

function set_int16_be(b: bytes, i: int, x: int): unit {
    if (Stdlib__Sys.big_endian) {
        return Caml_bytes.set16(b, i, x) as unit;
    } else {
        return Caml_bytes.set16(b, i, Caml_bytes.bswap16(x)) as unit;
    }
}

function set_int32_le(b: bytes, i: int, x: int): unit {
    if (Stdlib__Sys.big_endian) {
        return Caml_bytes.set32(b, i, Caml_bytes.bswap32(x)) as unit;
    } else {
        return Caml_bytes.set32(b, i, x) as unit;
    }
}

function set_int32_be(b: bytes, i: int, x: int): unit {
    if (Stdlib__Sys.big_endian) {
        return Caml_bytes.set32(b, i, x) as unit;
    } else {
        return Caml_bytes.set32(b, i, Caml_bytes.bswap32(x)) as unit;
    }
}

function set_int64_le(b: bytes, i: int, x: any): unit {
    if (Stdlib__Sys.big_endian) {
        return Caml_bytes.set64(b, i, Caml_bytes.bswap64(x)) as unit;
    } else {
        return Caml_bytes.set64(b, i, x) as unit;
    }
}

function set_int64_be(b: bytes, i: int, x: any): unit {
    if (Stdlib__Sys.big_endian) {
        return Caml_bytes.set64(b, i, x) as unit;
    } else {
        return Caml_bytes.set64(b, i, Caml_bytes.bswap64(x)) as unit;
    }
}

var set_uint8 = Caml_bytes.set as (b: bytes, i: int, x: int) => unit;

var set_uint16_ne = Caml_bytes.set16 as (b: bytes, i: int, x: int) => unit;

function dec_ret(n: int, u: int): any {
    return Stdlib__Uchar.utf_decode(n, Stdlib__Uchar.unsafe_of_int(u));
}

function not_in_x80_to_xBF(b: int): boolean {
    return b >>> 6 !== 2;
}

function not_in_xA0_to_xBF(b: int): boolean {
    return b >>> 5 !== 5;
}

function not_in_x80_to_x9F(b: int): boolean {
    return b >>> 5 !== 4;
}

function not_in_x90_to_xBF(b: int): boolean {
    if (b < 144) {
        return true;
    } else {
        return 191 < b;
    }
}

function not_in_x80_to_x8F(b: int): boolean {
    return b >>> 4 !== 8;
}

function utf_8_uchar_2(b0: int, b1: int): int {
    return (((b0 & 31) << 6) | (b1 & 63)) as int;
}

function utf_8_uchar_3(b0: int, b1: int, b2: int): int {
    return (((b0 & 15) << 12) | ((b1 & 63) << 6) | (b2 & 63)) as int;
}

function utf_8_uchar_4(b0: int, b1: int, b2: int, b3: int): int {
    return (
        ((b0 & 7) << 18) |
        ((b1 & 63) << 12) |
        ((b2 & 63) << 6) |
        (b3 & 63)
    ) as int;
}

function get_utf_8_uchar(b: bytes, i: int): any {
    var b0 = Caml_bytes.get(b, i);
    var max = (b.length - 1) | 0;
    var exit = 0;
    if (b0 >= 224) {
        if (b0 >= 237) {
            if (b0 >= 245) {
                return Stdlib__Uchar.utf_decode_invalid(1);
            }
            switch (b0) {
                case 237:
                    var i$1 = (i + 1) | 0;
                    if (i$1 > max) {
                        return Stdlib__Uchar.utf_decode_invalid(1);
                    }
                    var b1 = b[i$1]!;
                    if (b1 >>> 5 !== 4) {
                        return Stdlib__Uchar.utf_decode_invalid(1);
                    }
                    var i$2 = (i$1 + 1) | 0;
                    if (i$2 > max) {
                        return Stdlib__Uchar.utf_decode_invalid(2);
                    }
                    var b2 = b[i$2]!;
                    if (b2 >>> 6 !== 2) {
                        return Stdlib__Uchar.utf_decode_invalid(2);
                    } else {
                        return Stdlib__Uchar.utf_decode(
                            3,
                            Stdlib__Uchar.unsafe_of_int(
                                ((b0 & 15) << 12) |
                                    ((b1 & 63) << 6) |
                                    (b2 & 63),
                            ),
                        );
                    }
                case 238:
                case 239:
                    exit = 1;
                    break;
                case 240:
                    var i$3 = (i + 1) | 0;
                    if (i$3 > max) {
                        return Stdlib__Uchar.utf_decode_invalid(1);
                    }
                    var b1$1 = b[i$3]!;
                    if (b1$1 < 144 || 191 < b1$1) {
                        return Stdlib__Uchar.utf_decode_invalid(1);
                    }
                    var i$4 = (i$3 + 1) | 0;
                    if (i$4 > max) {
                        return Stdlib__Uchar.utf_decode_invalid(2);
                    }
                    var b2$1 = b[i$4]!;
                    if (b2$1 >>> 6 !== 2) {
                        return Stdlib__Uchar.utf_decode_invalid(2);
                    }
                    var i$5 = (i$4 + 1) | 0;
                    if (i$5 > max) {
                        return Stdlib__Uchar.utf_decode_invalid(3);
                    }
                    var b3 = b[i$5]!;
                    if (b3 >>> 6 !== 2) {
                        return Stdlib__Uchar.utf_decode_invalid(3);
                    } else {
                        return Stdlib__Uchar.utf_decode(
                            4,
                            Stdlib__Uchar.unsafe_of_int(
                                ((b0 & 7) << 18) |
                                    ((b1$1 & 63) << 12) |
                                    ((b2$1 & 63) << 6) |
                                    (b3 & 63),
                            ),
                        );
                    }
                case 241:
                case 242:
                case 243:
                    exit = 2;
                    break;
                case 244:
                    var i$6 = (i + 1) | 0;
                    if (i$6 > max) {
                        return Stdlib__Uchar.utf_decode_invalid(1);
                    }
                    var b1$2 = b[i$6]!;
                    if (b1$2 >>> 4 !== 8) {
                        return Stdlib__Uchar.utf_decode_invalid(1);
                    }
                    var i$7 = (i$6 + 1) | 0;
                    if (i$7 > max) {
                        return Stdlib__Uchar.utf_decode_invalid(2);
                    }
                    var b2$2 = b[i$7]!;
                    if (b2$2 >>> 6 !== 2) {
                        return Stdlib__Uchar.utf_decode_invalid(2);
                    }
                    var i$8 = (i$7 + 1) | 0;
                    if (i$8 > max) {
                        return Stdlib__Uchar.utf_decode_invalid(3);
                    }
                    var b3$1 = b[i$8]!;
                    if (b3$1 >>> 6 !== 2) {
                        return Stdlib__Uchar.utf_decode_invalid(3);
                    } else {
                        return Stdlib__Uchar.utf_decode(
                            4,
                            Stdlib__Uchar.unsafe_of_int(
                                ((b0 & 7) << 18) |
                                    ((b1$2 & 63) << 12) |
                                    ((b2$2 & 63) << 6) |
                                    (b3$1 & 63),
                            ),
                        );
                    }
            }
        } else if (b0 >= 225) {
            exit = 1;
        } else {
            var i$9 = (i + 1) | 0;
            if (i$9 > max) {
                return Stdlib__Uchar.utf_decode_invalid(1);
            }
            var b1$3 = b[i$9]!;
            if (b1$3 >>> 5 !== 5) {
                return Stdlib__Uchar.utf_decode_invalid(1);
            }
            var i$10 = (i$9 + 1) | 0;
            if (i$10 > max) {
                return Stdlib__Uchar.utf_decode_invalid(2);
            }
            var b2$3 = b[i$10]!;
            if (b2$3 >>> 6 !== 2) {
                return Stdlib__Uchar.utf_decode_invalid(2);
            } else {
                return Stdlib__Uchar.utf_decode(
                    3,
                    Stdlib__Uchar.unsafe_of_int(
                        ((b0 & 15) << 12) | ((b1$3 & 63) << 6) | (b2$3 & 63),
                    ),
                );
            }
        }
    } else {
        if (b0 < 128) {
            return Stdlib__Uchar.utf_decode(1, Stdlib__Uchar.unsafe_of_int(b0));
        }
        if (b0 < 194) {
            return Stdlib__Uchar.utf_decode_invalid(1);
        }
        var i$11 = (i + 1) | 0;
        if (i$11 > max) {
            return Stdlib__Uchar.utf_decode_invalid(1);
        }
        var b1$4 = b[i$11]!;
        if (b1$4 >>> 6 !== 2) {
            return Stdlib__Uchar.utf_decode_invalid(1);
        } else {
            return Stdlib__Uchar.utf_decode(
                2,
                Stdlib__Uchar.unsafe_of_int(((b0 & 31) << 6) | (b1$4 & 63)),
            );
        }
    }
    switch (exit) {
        case 1:
            var i$12 = (i + 1) | 0;
            if (i$12 > max) {
                return Stdlib__Uchar.utf_decode_invalid(1);
            }
            var b1$5 = b[i$12]!;
            if (b1$5 >>> 6 !== 2) {
                return Stdlib__Uchar.utf_decode_invalid(1);
            }
            var i$13 = (i$12 + 1) | 0;
            if (i$13 > max) {
                return Stdlib__Uchar.utf_decode_invalid(2);
            }
            var b2$4 = b[i$13]!;
            if (b2$4 >>> 6 !== 2) {
                return Stdlib__Uchar.utf_decode_invalid(2);
            } else {
                return Stdlib__Uchar.utf_decode(
                    3,
                    Stdlib__Uchar.unsafe_of_int(
                        ((b0 & 15) << 12) | ((b1$5 & 63) << 6) | (b2$4 & 63),
                    ),
                );
            }
        case 2:
            var i$14 = (i + 1) | 0;
            if (i$14 > max) {
                return Stdlib__Uchar.utf_decode_invalid(1);
            }
            var b1$6 = b[i$14]!;
            if (b1$6 >>> 6 !== 2) {
                return Stdlib__Uchar.utf_decode_invalid(1);
            }
            var i$15 = (i$14 + 1) | 0;
            if (i$15 > max) {
                return Stdlib__Uchar.utf_decode_invalid(2);
            }
            var b2$5 = b[i$15]!;
            if (b2$5 >>> 6 !== 2) {
                return Stdlib__Uchar.utf_decode_invalid(2);
            }
            var i$16 = (i$15 + 1) | 0;
            if (i$16 > max) {
                return Stdlib__Uchar.utf_decode_invalid(3);
            }
            var b3$2 = b[i$16]!;
            if (b3$2 >>> 6 !== 2) {
                return Stdlib__Uchar.utf_decode_invalid(3);
            } else {
                return Stdlib__Uchar.utf_decode(
                    4,
                    Stdlib__Uchar.unsafe_of_int(
                        ((b0 & 7) << 18) |
                            ((b1$6 & 63) << 12) |
                            ((b2$5 & 63) << 6) |
                            (b3$2 & 63),
                    ),
                );
            }
    }
}

function set_utf_8_uchar(b: bytes, i: int, u: int): int {
    var max = (b.length - 1) | 0;
    var u$1 = Stdlib__Uchar.to_int(u);
    if (u$1 < 0) {
        throw {
            RE_EXN_ID: "Assert_failure",
            _1: ["", 631, 20],
            Error: new Error(),
        };
    }
    if (u$1 <= 127) {
        Caml_bytes.set(b, i, u$1);
        return 1 as int;
    }
    if (u$1 <= 2047) {
        var last = (i + 1) | 0;
        if (last > max) {
            return 0 as int;
        } else {
            Caml_bytes.set(b, i, 192 | (u$1 >>> 6));
            b[last] = (128 | (u$1 & 63)) as int;
            return 2 as int;
        }
    }
    if (u$1 <= 65535) {
        var last$1 = (i + 2) | 0;
        if (last$1 > max) {
            return 0 as int;
        } else {
            Caml_bytes.set(b, i, 224 | (u$1 >>> 12));
            b[(i + 1) | 0] = (128 | ((u$1 >>> 6) & 63)) as int;
            b[last$1] = (128 | (u$1 & 63)) as int;
            return 3 as int;
        }
    }
    if (u$1 <= 1114111) {
        var last$2 = (i + 3) | 0;
        if (last$2 > max) {
            return 0 as int;
        } else {
            Caml_bytes.set(b, i, 240 | (u$1 >>> 18));
            b[(i + 1) | 0] = (128 | ((u$1 >>> 12) & 63)) as int;
            b[(i + 2) | 0] = (128 | ((u$1 >>> 6) & 63)) as int;
            b[last$2] = (128 | (u$1 & 63)) as int;
            return 4 as int;
        }
    }
    throw {
        RE_EXN_ID: "Assert_failure",
        _1: ["", 656, 9],
        Error: new Error(),
    };
}

function is_valid_utf_8(b: bytes): bool {
    var max = (b.length - 1) | 0;
    var _i = 0;
    while (true) {
        var i = _i;
        if (i > max) {
            return true;
        }
        var match = b[i]!;
        var exit = 0;
        if (match >= 224) {
            if (match >= 237) {
                if (match >= 245) {
                    return false;
                }
                switch (match) {
                    case 237:
                        var last = (i + 2) | 0;
                        if (
                            last > max ||
                            b[(i + 1) | 0]! >>> 5 !== 4 ||
                            b[last]! >>> 6 !== 2
                        ) {
                            return false;
                        }
                        _i = (last + 1) | 0;
                        continue;
                    case 238:
                    case 239:
                        exit = 1;
                        break;
                    case 240:
                        var last$1 = (i + 3) | 0;
                        var tmp = true;
                        if (last$1 <= max) {
                            var b$1 = b[(i + 1) | 0]!;
                            tmp =
                                b$1 < 144 ||
                                191 < b$1 ||
                                b[(i + 2) | 0]! >>> 6 !== 2 ||
                                b[last$1]! >>> 6 !== 2;
                        }
                        if (tmp) {
                            return false;
                        }
                        _i = (last$1 + 1) | 0;
                        continue;
                    case 241:
                    case 242:
                    case 243:
                        exit = 2;
                        break;
                    case 244:
                        var last$2 = (i + 3) | 0;
                        if (
                            last$2 > max ||
                            b[(i + 1) | 0]! >>> 4 !== 8 ||
                            b[(i + 2) | 0]! >>> 6 !== 2 ||
                            b[last$2]! >>> 6 !== 2
                        ) {
                            return false;
                        }
                        _i = (last$2 + 1) | 0;
                        continue;
                }
            } else if (match >= 225) {
                exit = 1;
            } else {
                var last$3 = (i + 2) | 0;
                if (
                    last$3 > max ||
                    b[(i + 1) | 0]! >>> 5 !== 5 ||
                    b[last$3]! >>> 6 !== 2
                ) {
                    return false;
                }
                _i = (last$3 + 1) | 0;
                continue;
            }
        } else {
            if (match >= 128) {
                if (match < 194) {
                    return false;
                }
                var last$4 = (i + 1) | 0;
                if (last$4 > max || b[last$4]! >>> 6 !== 2) {
                    return false;
                }
                _i = (last$4 + 1) | 0;
                continue;
            }
            _i = (i + 1) | 0;
            continue;
        }
        switch (exit) {
            case 1:
                var last$5 = (i + 2) | 0;
                if (
                    last$5 > max ||
                    b[(i + 1) | 0]! >>> 6 !== 2 ||
                    b[last$5]! >>> 6 !== 2
                ) {
                    return false;
                }
                _i = (last$5 + 1) | 0;
                continue;
            case 2:
                var last$6 = (i + 3) | 0;
                if (
                    last$6 > max ||
                    b[(i + 1) | 0]! >>> 6 !== 2 ||
                    b[(i + 2) | 0]! >>> 6 !== 2 ||
                    b[last$6]! >>> 6 !== 2
                ) {
                    return false;
                }
                _i = (last$6 + 1) | 0;
                continue;
        }
    }
}

function get_utf_16be_uchar(b: bytes, i: int): any {
    var max = (b.length - 1) | 0;
    if (i < 0 || i > max) {
        return Stdlib.invalid_arg("index out of bounds");
    }
    if (i === max) {
        return Stdlib__Uchar.utf_decode_invalid(1);
    }
    var u = unsafe_get_uint16_be(b, i);
    if (u < 55296 || u > 57343) {
        return Stdlib__Uchar.utf_decode(2, Stdlib__Uchar.unsafe_of_int(u));
    }
    if (u > 56319) {
        return Stdlib__Uchar.utf_decode_invalid(2);
    }
    var last = (i + 3) | 0;
    if (last > max) {
        return Stdlib__Uchar.utf_decode_invalid((((max - i) | 0) + 1) | 0);
    }
    var u$1 = unsafe_get_uint16_be(b, ((i + 2) | 0) as int);
    if (u$1 < 56320 || u$1 > 57343) {
        return Stdlib__Uchar.utf_decode_invalid(2);
    }
    var u$2 = ((((u & 1023) << 10) | (u$1 & 1023)) + 65536) | 0;
    return Stdlib__Uchar.utf_decode(4, Stdlib__Uchar.unsafe_of_int(u$2));
}

function set_utf_16be_uchar(b: bytes, i: int, u: any): int {
    var max = (b.length - 1) | 0;
    if (i < 0 || i > max) {
        return Stdlib.invalid_arg("index out of bounds");
    }
    var u$1 = Stdlib__Uchar.to_int(u);
    if (u$1 < 0) {
        throw {
            RE_EXN_ID: "Assert_failure",
            _1: ["", 743, 20],
            Error: new Error(),
        };
    }
    if (u$1 <= 65535) {
        var last = (i + 1) | 0;
        if (last > max) {
            return 0 as int;
        } else {
            unsafe_set_uint16_be(b, i, u$1);
            return 2 as int;
        }
    }
    if (u$1 <= 1114111) {
        var last$1 = (i + 3) | 0;
        if (last$1 > max) {
            return 0 as int;
        }
        var u$p = (u$1 - 65536) | 0;
        var hi = 55296 | (u$p >>> 10);
        var lo = 56320 | (u$p & 1023);
        unsafe_set_uint16_be(b, i, hi as int);
        unsafe_set_uint16_be(b, ((i + 2) | 0) as int, lo as int);
        return 4 as int;
    }
    throw {
        RE_EXN_ID: "Assert_failure",
        _1: ["", 754, 9],
        Error: new Error(),
    };
}

function is_valid_utf_16be(b: bytes): bool {
    var max = (b.length - 1) | 0;
    var _i = 0;
    while (true) {
        var i = _i;
        if (i > max) {
            return true;
        }
        if (i === max) {
            return false;
        }
        var u = unsafe_get_uint16_be(b, i as int);
        if (u < 55296 || u > 57343) {
            _i = (i + 2) | 0;
            continue;
        }
        if (u > 56319) {
            return false;
        }
        var last = (i + 3) | 0;
        if (last > max) {
            return false;
        }
        var u$1 = unsafe_get_uint16_be(b, ((i + 2) | 0) as int);
        if (u$1 < 56320 || u$1 > 57343) {
            return false;
        }
        _i = (i + 4) | 0;
        continue;
    }
}

function get_utf_16le_uchar(b: bytes, i: int): any {
    var max = (b.length - 1) | 0;
    if (i < 0 || i > max) {
        return Stdlib.invalid_arg("index out of bounds");
    }
    if (i === max) {
        return Stdlib__Uchar.utf_decode_invalid(1);
    }
    var u = unsafe_get_uint16_le(b, i);
    if (u < 55296 || u > 57343) {
        return Stdlib__Uchar.utf_decode(2, Stdlib__Uchar.unsafe_of_int(u));
    }
    if (u > 56319) {
        return Stdlib__Uchar.utf_decode_invalid(2);
    }
    var last = (i + 3) | 0;
    if (last > max) {
        return Stdlib__Uchar.utf_decode_invalid((((max - i) | 0) + 1) | 0);
    }
    var u$1 = unsafe_get_uint16_le(b, ((i + 2) | 0) as int);
    if (u$1 < 56320 || u$1 > 57343) {
        return Stdlib__Uchar.utf_decode_invalid(2);
    }
    var u$2 = ((((u & 1023) << 10) | (u$1 & 1023)) + 65536) | 0;
    return Stdlib__Uchar.utf_decode(4, Stdlib__Uchar.unsafe_of_int(u$2));
}

function set_utf_16le_uchar(b: bytes, i: int, u: any): int {
    var max = (b.length - 1) | 0;
    if (i < 0 || i > max) {
        return Stdlib.invalid_arg("index out of bounds");
    }
    var u$1 = Stdlib__Uchar.to_int(u);
    if (u$1 < 0) {
        throw {
            RE_EXN_ID: "Assert_failure",
            _1: ["", 797, 20],
            Error: new Error(),
        };
    }
    if (u$1 <= 65535) {
        var last = (i + 1) | 0;
        if (last > max) {
            return 0 as int;
        } else {
            unsafe_set_uint16_le(b, i, u$1);
            return 2 as int;
        }
    }
    if (u$1 <= 1114111) {
        var last$1 = (i + 3) | 0;
        if (last$1 > max) {
            return 0 as int;
        }
        var u$p = (u$1 - 65536) | 0;
        var hi = 55296 | (u$p >>> 10);
        var lo = 56320 | (u$p & 1023);
        unsafe_set_uint16_le(b, i, hi as int);
        unsafe_set_uint16_le(b, ((i + 2) | 0) as int, lo as int);
        return 4 as int;
    }
    throw {
        RE_EXN_ID: "Assert_failure",
        _1: ["", 808, 9],
        Error: new Error(),
    };
}

function is_valid_utf_16le(b: bytes): bool {
    var max = (b.length - 1) | 0;
    var _i = 0;
    while (true) {
        var i = _i;
        if (i > max) {
            return true;
        }
        if (i === max) {
            return false;
        }
        var u = unsafe_get_uint16_le(b, i as int);
        if (u < 55296 || u > 57343) {
            _i = (i + 2) | 0;
            continue;
        }
        if (u > 56319) {
            return false;
        }
        var last = (i + 3) | 0;
        if (last > max) {
            return false;
        }
        var u$1 = unsafe_get_uint16_le(b, ((i + 2) | 0) as int);
        if (u$1 < 56320 || u$1 > 57343) {
            return false;
        }
        _i = (i + 4) | 0;
        continue;
    }
}

var set_uint16_be = set_int16_be;

var set_uint16_le = set_int16_le;

var dec_invalid = Stdlib__Uchar.utf_decode_invalid;

export {
    make,
    init,
    empty,
    copy,
    to_string,
    of_string,
    sub,
    sub_string,
    $plus$plus,
    extend,
    fill,
    blit,
    blit_string,
    iter,
    iteri,
    ensure_ge,
    sum_lengths,
    unsafe_blits,
    concat,
    cat,
    is_space,
    trim,
    unsafe_escape,
    escaped,
    map,
    mapi,
    fold_left,
    fold_right,
    exists,
    for_all,
    uppercase_ascii,
    lowercase_ascii,
    apply1,
    capitalize_ascii,
    uncapitalize_ascii,
    starts_with,
    ends_with,
    index_rec,
    index,
    index_rec_opt,
    index_opt,
    index_from,
    index_from_opt,
    rindex_rec,
    rindex,
    rindex_from,
    rindex_rec_opt,
    rindex_opt,
    rindex_from_opt,
    contains_from,
    contains,
    rcontains_from,
    compare,
    split_on_char,
    to_seq,
    to_seqi,
    of_seq,
    unsafe_get_uint16_le,
    unsafe_get_uint16_be,
    get_int8,
    get_uint16_le,
    get_uint16_be,
    get_int16_ne,
    get_int16_le,
    get_int16_be,
    get_int32_le,
    get_int32_be,
    get_int64_le,
    get_int64_be,
    unsafe_set_uint16_le,
    unsafe_set_uint16_be,
    set_int16_le,
    set_int16_be,
    set_int32_le,
    set_int32_be,
    set_int64_le,
    set_int64_be,
    set_uint8,
    set_uint16_ne,
    set_uint16_be,
    set_uint16_le,
    dec_invalid,
    dec_ret,
    not_in_x80_to_xBF,
    not_in_xA0_to_xBF,
    not_in_x80_to_x9F,
    not_in_x90_to_xBF,
    not_in_x80_to_x8F,
    utf_8_uchar_2,
    utf_8_uchar_3,
    utf_8_uchar_4,
    get_utf_8_uchar,
    set_utf_8_uchar,
    is_valid_utf_8,
    get_utf_16be_uchar,
    set_utf_16be_uchar,
    is_valid_utf_16be,
    get_utf_16le_uchar,
    set_utf_16le_uchar,
    is_valid_utf_16le,
};
/* No side effect */
