// Generated by Melange

import * as Caml_array from "../melange.js/caml_array.mjs";
import * as Caml_js_exceptions from "../melange.js/caml_js_exceptions.mjs";
import * as Caml_option from "../melange.js/caml_option.mjs";
import * as CamlinternalLazy from "./camlinternalLazy.mjs";
import * as Curry from "../melange.js/curry.mjs";
import * as Stdlib from "./stdlib.mjs";
import * as Stdlib__Array from "./array.mjs";
import * as Stdlib__Hashtbl from "./hashtbl.mjs";
import * as Stdlib__Int from "./int.mjs";
import * as Stdlib__List from "./list.mjs";
import * as Stdlib__Obj from "./obj.mjs";
import * as Stdlib__Random from "./random.mjs";
import * as Stdlib__Seq from "./seq.mjs";
import * as Stdlib__Sys from "./sys.mjs";

function set_key(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 0, k);
}

function check_key(t) {
  return Stdlib__Obj.Ephemeron.check_key(t, 0);
}

function get_data(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function make(key, data) {
  var eph = Stdlib__Obj.Ephemeron.create(1);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  set_key(eph, key);
  return eph;
}

function query(eph, key) {
  var k = Stdlib__Obj.Ephemeron.get_key(eph, 0);
  if (k !== undefined && Caml_option.valFromOption(k) === key) {
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  
}

function MakeSeeded(H) {
  var create = function (k, d) {
    var c = Stdlib__Obj.Ephemeron.create(1);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key(c, k);
    return c;
  };
  var seeded_hash = H.seeded_hash;
  var equal = function (c, k) {
    var k$p = Stdlib__Obj.Ephemeron.get_key(c, 0);
    if (k$p !== undefined) {
      if (Curry._2(H.equal, k, Caml_option.valFromOption(k$p))) {
        return /* ETrue */0;
      } else {
        return /* EFalse */1;
      }
    } else {
      return /* EDead */2;
    }
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = Curry._2(seeded_hash, h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = Curry._2(seeded_hash, h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = Curry._2(seeded_hash, h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            RE_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = Curry._2(seeded_hash, h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = Curry._2(seeded_hash, h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = Curry._2(seeded_hash, h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key(c, key);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              RE_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = Curry._2(seeded_hash, h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var of_seq = function (i) {
    var tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$1,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function Make(H) {
  var equal = H.equal;
  var seeded_hash = function (_seed, x) {
    return Curry._1(H.hash, x);
  };
  var create = function (k, d) {
    var c = Stdlib__Obj.Ephemeron.create(1);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key(c, k);
    return c;
  };
  var equal$1 = function (c, k) {
    var k$p = Stdlib__Obj.Ephemeron.get_key(c, 0);
    if (k$p !== undefined) {
      if (Curry._2(equal, k, Caml_option.valFromOption(k$p))) {
        return /* ETrue */0;
      } else {
        return /* EFalse */1;
      }
    } else {
      return /* EDead */2;
    }
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal$1(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$1(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            RE_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal$1(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$1(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal$1(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key(c, key);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              RE_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal$1(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var create$2 = function (sz) {
    return create$1(false, sz);
  };
  var of_seq = function (i) {
    var tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$2,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function make$1(param) {
  return {
          contents: /* [] */0
        };
}

function add(b, k, d) {
  b.contents = {
    hd: make(k, d),
    tl: b.contents
  };
}

function test_key(k, e) {
  var x = Stdlib__Obj.Ephemeron.get_key(e, 0);
  if (x !== undefined) {
    return Caml_option.valFromOption(x) === k;
  } else {
    return false;
  }
}

function remove(b, k) {
  var _l = b.contents;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var l = _l;
    if (!l) {
      return ;
    }
    var h = l.hd;
    if (test_key(k, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return ;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue ;
  };
}

function find(b, k) {
  var e = Stdlib__List.find_opt((function (param) {
          return test_key(k, param);
        }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length(b) {
  return Stdlib__List.length(b.contents);
}

function clear(b) {
  b.contents = /* [] */0;
}

function set_key1(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 0, k);
}

function set_key2(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 1, k);
}

function get_data$1(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function make$2(key1, key2, data) {
  var eph = Stdlib__Obj.Ephemeron.create(2);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  set_key1(eph, key1);
  set_key2(eph, key2);
  return eph;
}

function query$1(eph, key1, key2) {
  var k = Stdlib__Obj.Ephemeron.get_key(eph, 0);
  if (k === undefined) {
    return ;
  }
  if (Caml_option.valFromOption(k) !== key1) {
    return ;
  }
  var k$1 = Stdlib__Obj.Ephemeron.get_key(eph, 1);
  if (k$1 !== undefined && Caml_option.valFromOption(k$1) === key2) {
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  
}

function MakeSeeded$1(H1, H2) {
  var create = function (param, d) {
    var c = Stdlib__Obj.Ephemeron.create(2);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key1(c, param[0]);
    set_key2(c, param[1]);
    return c;
  };
  var seeded_hash = function (seed, param) {
    return Curry._2(H1.seeded_hash, seed, param[0]) + Math.imul(Curry._2(H2.seeded_hash, seed, param[1]), 65599) | 0;
  };
  var equal = function (c, param) {
    var match = Stdlib__Obj.Ephemeron.get_key(c, 0);
    var match$1 = Stdlib__Obj.Ephemeron.get_key(c, 1);
    if (match !== undefined && match$1 !== undefined) {
      if (Curry._2(H1.equal, param[0], Caml_option.valFromOption(match)) && Curry._2(H2.equal, param[1], Caml_option.valFromOption(match$1))) {
        return /* ETrue */0;
      } else {
        return /* EFalse */1;
      }
    } else {
      return /* EDead */2;
    }
  };
  var check_key = function (c) {
    if (Stdlib__Obj.Ephemeron.check_key(c, 0)) {
      return Stdlib__Obj.Ephemeron.check_key(c, 1);
    } else {
      return false;
    }
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$1(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            RE_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data$1(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$1(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key1(c, key[0]);
              set_key2(c, key[1]);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              RE_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var of_seq = function (i) {
    var tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$1,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function Make$1(H1, H2) {
  var equal = H2.equal;
  var equal$1 = H1.equal;
  var create = function (param, d) {
    var c = Stdlib__Obj.Ephemeron.create(2);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key1(c, param[0]);
    set_key2(c, param[1]);
    return c;
  };
  var seeded_hash = function (seed, param) {
    return Curry._1(H1.hash, param[0]) + Math.imul(Curry._1(H2.hash, param[1]), 65599) | 0;
  };
  var equal$2 = function (c, param) {
    var match = Stdlib__Obj.Ephemeron.get_key(c, 0);
    var match$1 = Stdlib__Obj.Ephemeron.get_key(c, 1);
    if (match !== undefined && match$1 !== undefined) {
      if (Curry._2(equal$1, param[0], Caml_option.valFromOption(match)) && Curry._2(equal, param[1], Caml_option.valFromOption(match$1))) {
        return /* ETrue */0;
      } else {
        return /* EFalse */1;
      }
    } else {
      return /* EDead */2;
    }
  };
  var check_key = function (c) {
    if (Stdlib__Obj.Ephemeron.check_key(c, 0)) {
      return Stdlib__Obj.Ephemeron.check_key(c, 1);
    } else {
      return false;
    }
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal$2(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$2(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$1(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            RE_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal$2(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data$1(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$2(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$1(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal$2(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key1(c, key[0]);
              set_key2(c, key[1]);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              RE_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal$2(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var create$2 = function (sz) {
    return create$1(false, sz);
  };
  var of_seq = function (i) {
    var tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$2,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function make$3(param) {
  return {
          contents: /* [] */0
        };
}

function add$1(b, k1, k2, d) {
  b.contents = {
    hd: make$2(k1, k2, d),
    tl: b.contents
  };
}

function test_keys(k1, k2, e) {
  var match = Stdlib__Obj.Ephemeron.get_key(e, 0);
  var match$1 = Stdlib__Obj.Ephemeron.get_key(e, 1);
  if (match !== undefined && match$1 !== undefined && Caml_option.valFromOption(match) === k1) {
    return Caml_option.valFromOption(match$1) === k2;
  } else {
    return false;
  }
}

function remove$1(b, k1, k2) {
  var _l = b.contents;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var l = _l;
    if (!l) {
      return ;
    }
    var h = l.hd;
    if (test_keys(k1, k2, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return ;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue ;
  };
}

function find$1(b, k1, k2) {
  var e = Stdlib__List.find_opt((function (param) {
          return test_keys(k1, k2, param);
        }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length$1(b) {
  return Stdlib__List.length(b.contents);
}

function clear$1(b) {
  b.contents = /* [] */0;
}

function set_key$1(t, n, k) {
  Stdlib__Obj.Ephemeron.set_key(t, n, k);
}

function get_data$2(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function make$4(keys, data) {
  var l = keys.length;
  var eph = Stdlib__Obj.Ephemeron.create(l);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  for(var i = 0; i < l; ++i){
    set_key$1(eph, i, Caml_array.get(keys, i));
  }
  return eph;
}

function query$2(eph, keys) {
  var l = Stdlib__Obj.Ephemeron.length(eph);
  try {
    if (l !== keys.length) {
      throw {
            RE_EXN_ID: Stdlib.Exit,
            Error: new Error()
          };
    }
    for(var i = 0; i < l; ++i){
      var k = Stdlib__Obj.Ephemeron.get_key(eph, i);
      if (k !== undefined) {
        if (Caml_option.valFromOption(k) !== Caml_array.get(keys, i)) {
          throw {
                RE_EXN_ID: Stdlib.Exit,
                Error: new Error()
              };
        }
        
      } else {
        throw {
              RE_EXN_ID: Stdlib.Exit,
              Error: new Error()
            };
      }
    }
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib.Exit) {
      return ;
    }
    throw exn;
  }
}

function MakeSeeded$2(H) {
  var create = function (k, d) {
    var c = Stdlib__Obj.Ephemeron.create(k.length);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      set_key$1(c, i, Caml_array.get(k, i));
    }
    return c;
  };
  var seeded_hash = function (seed, k) {
    var h = 0;
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      h = Math.imul(Curry._2(H.seeded_hash, seed, Caml_array.get(k, i)), 65599) + h | 0;
    }
    return h;
  };
  var equal = function (c, k) {
    var len = k.length;
    var len$p = Stdlib__Obj.Ephemeron.length(c);
    if (len !== len$p) {
      return /* EFalse */1;
    }
    var _i = len - 1 | 0;
    while(true) {
      var i = _i;
      if (i < 0) {
        return /* ETrue */0;
      }
      var ki = Stdlib__Obj.Ephemeron.get_key(c, i);
      if (ki === undefined) {
        return /* EDead */2;
      }
      if (!Curry._2(H.equal, Caml_array.get(k, i), Caml_option.valFromOption(ki))) {
        return /* EFalse */1;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  var check_key = function (c) {
    var _i = Stdlib__Obj.Ephemeron.length(c) - 1 | 0;
    while(true) {
      var i = _i;
      if (i < 0) {
        return true;
      }
      if (!Stdlib__Obj.Ephemeron.check_key(c, i)) {
        return false;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$2(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            RE_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data$2(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$2(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              for(var i$1 = 0 ,i_finish = key.length; i$1 < i_finish; ++i$1){
                set_key$1(c, i$1, Caml_array.get(key, i$1));
              }
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              RE_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var of_seq = function (i) {
    var tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$1,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function Make$2(H) {
  var equal = H.equal;
  var create = function (k, d) {
    var c = Stdlib__Obj.Ephemeron.create(k.length);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      set_key$1(c, i, Caml_array.get(k, i));
    }
    return c;
  };
  var seeded_hash = function (seed, k) {
    var h = 0;
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      h = Math.imul(Curry._1(H.hash, Caml_array.get(k, i)), 65599) + h | 0;
    }
    return h;
  };
  var equal$1 = function (c, k) {
    var len = k.length;
    var len$p = Stdlib__Obj.Ephemeron.length(c);
    if (len !== len$p) {
      return /* EFalse */1;
    }
    var _i = len - 1 | 0;
    while(true) {
      var i = _i;
      if (i < 0) {
        return /* ETrue */0;
      }
      var ki = Stdlib__Obj.Ephemeron.get_key(c, i);
      if (ki === undefined) {
        return /* EDead */2;
      }
      if (!Curry._2(equal, Caml_array.get(k, i), Caml_option.valFromOption(ki))) {
        return /* EFalse */1;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  var check_key = function (c) {
    var _i = Stdlib__Obj.Ephemeron.length(c) - 1 | 0;
    while(true) {
      var i = _i;
      if (i < 0) {
        return true;
      }
      if (!Stdlib__Obj.Ephemeron.check_key(c, i)) {
        return false;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal$1(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$1(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$2(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            RE_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal$1(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data$2(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$1(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$2(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal$1(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              for(var i$1 = 0 ,i_finish = key.length; i$1 < i_finish; ++i$1){
                set_key$1(c, i$1, Caml_array.get(key, i$1));
              }
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              RE_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal$1(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var create$2 = function (sz) {
    return create$1(false, sz);
  };
  var of_seq = function (i) {
    var tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$2,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function make$5(param) {
  return {
          contents: /* [] */0
        };
}

function add$2(b, k, d) {
  b.contents = {
    hd: make$4(k, d),
    tl: b.contents
  };
}

function test_keys$1(k, e) {
  try {
    if (Stdlib__Obj.Ephemeron.length(e) !== k.length) {
      throw {
            RE_EXN_ID: Stdlib.Exit,
            Error: new Error()
          };
    }
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      var x = Stdlib__Obj.Ephemeron.get_key(e, i);
      if (x !== undefined) {
        if (Caml_option.valFromOption(x) !== Caml_array.get(k, i)) {
          throw {
                RE_EXN_ID: Stdlib.Exit,
                Error: new Error()
              };
        }
        
      } else {
        throw {
              RE_EXN_ID: Stdlib.Exit,
              Error: new Error()
            };
      }
    }
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib.Exit) {
      return false;
    }
    throw exn;
  }
}

function remove$2(b, k) {
  var _l = b.contents;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var l = _l;
    if (!l) {
      return ;
    }
    var h = l.hd;
    if (test_keys$1(k, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return ;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue ;
  };
}

function find$2(b, k) {
  var e = Stdlib__List.find_opt((function (param) {
          return test_keys$1(k, param);
        }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length$2(b) {
  return Stdlib__List.length(b.contents);
}

function clear$2(b) {
  b.contents = /* [] */0;
}

var K1_Bucket = {
  make: make$1,
  add: add,
  remove: remove,
  find: find,
  length: length,
  clear: clear
};

var K1 = {
  make: make,
  query: query,
  Make: Make,
  MakeSeeded: MakeSeeded,
  Bucket: K1_Bucket
};

var K2_Bucket = {
  make: make$3,
  add: add$1,
  remove: remove$1,
  find: find$1,
  length: length$1,
  clear: clear$1
};

var K2 = {
  make: make$2,
  query: query$1,
  Make: Make$1,
  MakeSeeded: MakeSeeded$1,
  Bucket: K2_Bucket
};

var Kn_Bucket = {
  make: make$5,
  add: add$2,
  remove: remove$2,
  find: find$2,
  length: length$2,
  clear: clear$2
};

var Kn = {
  make: make$4,
  query: query$2,
  Make: Make$2,
  MakeSeeded: MakeSeeded$2,
  Bucket: Kn_Bucket
};

export {
  K1 ,
  K2 ,
  Kn ,
}
/* Stdlib__Hashtbl Not a pure module */
